# constants.py
WINDOW_WIDTH = 600
WINDOW_HEIGHT = 600
PLAYER_SIZE = 50
OBSTACLE_SIZE = 30
COLLECTIBLE_SIZE = 20
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
RED = (255, 0, 0)
BLACK = (0, 0, 0)
ORANGE = (255, 165, 0)
GRID_COLOR = (200, 200, 200)
PLAYER_SPEED = 5
FPS = 60
NUM_OBSTACLES = 8

# game_state.py
import pygame
import random

from constants import (WINDOW_WIDTH, WINDOW_HEIGHT, PLAYER_SIZE, OBSTACLE_SIZE,
                       COLLECTIBLE_SIZE, PLAYER_SPEED, NUM_OBSTACLES)


def check_collision(x1, y1, size1, x2, y2, size2):
    return (x1 <= x2 + size2 and
            x1 + size1 >= x2 and
            y1 <= y2 + size2 and
            y1 + size1 >= y2)


class GameState:
    def __init__(self, debug_mode):
        self.debug_mode = debug_mode
        self.player_x = WINDOW_WIDTH // 2 - PLAYER_SIZE // 2
        self.player_y = WINDOW_HEIGHT // 2 - PLAYER_SIZE // 2
        self.score = 0
        self.flash_timer = 0
        self.flash_duration = 10
        self.obstacles = self.generate_obstacles()
        self.collectible = self.generate_collectible()

    def generate_obstacles(self):
        new_obstacles = []
        max_attempts = 100
        safe_margin = PLAYER_SIZE

        for _ in range(NUM_OBSTACLES):
            attempts = 0
            while attempts < max_attempts:
                x = random.randint(PLAYER_SIZE, WINDOW_WIDTH - OBSTACLE_SIZE - PLAYER_SIZE)
                y = random.randint(PLAYER_SIZE, WINDOW_HEIGHT - OBSTACLE_SIZE - PLAYER_SIZE)

                is_safe = True
                for obs in new_obstacles:
                    min_distance = PLAYER_SIZE + OBSTACLE_SIZE + 20
                    if (abs(x - obs[0]) < min_distance and
                            abs(y - obs[1]) < min_distance):
                        is_safe = False
                        break

                if is_safe:
                    new_obstacles.append([x, y])
                    break
                attempts += 1
        return new_obstacles

    def generate_collectible(self):
        while True:
            new_x = random.randint(0, WINDOW_WIDTH - COLLECTIBLE_SIZE)
            new_y = random.randint(0, WINDOW_HEIGHT - COLLECTIBLE_SIZE)
            if self.is_position_safe(new_x, new_y, COLLECTIBLE_SIZE):
                return [new_x, new_y]

    def is_position_safe(self, x, y, size, obstacles=None):
        obstacles = obstacles or self.obstacles
        if x < PLAYER_SIZE or x > WINDOW_WIDTH - size - PLAYER_SIZE or y < PLAYER_SIZE or y > WINDOW_HEIGHT - size - PLAYER_SIZE:
            return False

        for obs in obstacles:
            if check_collision(x, y, size, obs[0], obs[1], OBSTACLE_SIZE):
                return False
        return True



# renderer.py
import pygame
from constants import (WINDOW_WIDTH, WINDOW_HEIGHT, PLAYER_SIZE, OBSTACLE_SIZE,
                       COLLECTIBLE_SIZE, WHITE, BLUE, RED, BLACK, ORANGE,
                       GRID_COLOR)

class Renderer:
    def __init__(self, screen, debug_mode):
        self.screen = screen
        self.debug_mode = debug_mode
        self.font = pygame.font.Font(None, 36)


    def render(self, game_state):
        self.screen.fill(WHITE)

        if self.debug_mode:
            grid_size = 100
            for x in range(0, WINDOW_WIDTH, grid_size):
                pygame.draw.line(self.screen, GRID_COLOR, (x, 0), (x, WINDOW_HEIGHT))
            for y in range(0, WINDOW_HEIGHT, grid_size):
                pygame.draw.line(self.screen, GRID_COLOR, (0, y), (WINDOW_WIDTH, y))

        for i, obstacle in enumerate(game_state.obstacles):
            pygame.draw.rect(self.screen, RED,
                             (obstacle[0], obstacle[1], OBSTACLE_SIZE, OBSTACLE_SIZE))
            if self.debug_mode:
                pygame.draw.circle(self.screen, BLACK, (obstacle[0], obstacle[1]), 3)
                number_text = self.font.render(str(i), True, BLACK)
                text_rect = number_text.get_rect(center=(obstacle[0] + OBSTACLE_SIZE / 2, obstacle[1] + OBSTACLE_SIZE / 2))
                self.screen.blit(number_text, text_rect)

        pygame.draw.rect(self.screen, BLACK,
                         (game_state.collectible[0], game_state.collectible[1], COLLECTIBLE_SIZE, COLLECTIBLE_SIZE))

        player_color = ORANGE if game_state.flash_timer > 0 else BLUE
        pygame.draw.rect(self.screen, player_color,
                         (game_state.player_x, game_state.player_y, PLAYER_SIZE, PLAYER_SIZE))

        score_text = self.font.render(f'Score: {game_state.score}', True, BLACK)
        self.screen.blit(score_text, (10, 10))

        if self.debug_mode:
            pygame.draw.circle(self.screen, (255, 0, 0), (game_state.player_x, game_state.player_y), 3)
            pygame.draw.circle(self.screen, (0, 255, 0), (game_state.collectible[0], game_state.collectible[1]), 3)

        pygame.display.flip()



import pygame
import sys
import os
import argparse

from game_state import GameState, check_collision
from renderer import Renderer
from constants import (WINDOW_WIDTH, WINDOW_HEIGHT, PLAYER_SIZE, OBSTACLE_SIZE,
                       COLLECTIBLE_SIZE, WHITE, BLUE, RED, BLACK, ORANGE,
                       GRID_COLOR, PLAYER_SPEED, FPS, NUM_OBSTACLES)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--debug',
                        action='store_true',
                        help='Enable debug features')
    parser.add_argument('--ai', action='store_true', help='Enable AI player')
    args = parser.parse_args()
    print("Starting game...")
    print("Initializing pygame...")
    pygame.init()
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    pygame.display.set_caption("Move the Square Game")

    game_state = GameState(args.debug)
    renderer = Renderer(screen, args.debug)
    clock = pygame.time.Clock()

    ai_player = None
    if args.ai:
        from ai_player import AIPlayer
        ai_player = AIPlayer()

    while True:
        state = None
        action = None
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        old_x, old_y = game_state.player_x, game_state.player_y

        if args.ai and ai_player is not None:
            state = ai_player.get_state(game_state.player_x,
                                        game_state.player_y,
                                        game_state.collectible[0],
                                        game_state.collectible[1])
            action = ai_player.get_action(state)
            dx, dy = ai_player.actions[action]
            game_state.player_x += dx
            game_state.player_y += dy
        else:
            keys = pygame.key.get_pressed()
            if keys[pygame.K_LEFT]:
                game_state.player_x -= PLAYER_SPEED
            if keys[pygame.K_RIGHT]:
                game_state.player_x += PLAYER_SPEED
            if keys[pygame.K_UP]:
                game_state.player_y -= PLAYER_SPEED
            if keys[pygame.K_DOWN]:
                game_state.player_y += PLAYER_SPEED

        game_state.player_x = max(
            0, min(WINDOW_WIDTH - PLAYER_SIZE, game_state.player_x))
        game_state.player_y = max(
            0, min(WINDOW_HEIGHT - PLAYER_SIZE, game_state.player_y))

        for obstacle in game_state.obstacles:
            if check_collision(game_state.player_x, game_state.player_y,
                               PLAYER_SIZE, obstacle[0], obstacle[1],
                               OBSTACLE_SIZE):
                game_state.player_x, game_state.player_y = old_x, old_y
                game_state.flash_timer = game_state.flash_duration
                if args.ai and ai_player is not None and state is not None and action is not None:
                    new_state = ai_player.get_state(game_state.player_x,
                                                    game_state.player_y,
                                                    game_state.collectible[0],
                                                    game_state.collectible[1])
                    ai_player.update(state, action, -1.0, new_state)  # Negative reward for hitting obstacle

        reward = 0
        if check_collision(game_state.player_x, game_state.player_y,
                           PLAYER_SIZE, game_state.collectible[0],
                           game_state.collectible[1], COLLECTIBLE_SIZE):
            reward = 100
            game_state.score += 10
            game_state.obstacles = game_state.generate_obstacles()
            game_state.collectible = game_state.generate_collectible()

        if args.ai and ai_player is not None:
            current_state = ai_player.get_state(game_state.player_x,
                                                game_state.player_y,
                                                game_state.collectible[0],
                                                game_state.collectible[1])
            if any(
                check_collision(game_state.player_x, game_state.player_y,
                                PLAYER_SIZE, obs[0], obs[1], OBSTACLE_SIZE)
                for obs in game_state.obstacles):
                reward = -50

            if state is not None and action is not None:
                ai_player.update(state, action, reward, current_state)
                if reward != 0:
                    print(f"Score: {game_state.score}")
                    print("-" * 40)
            state = current_state

        if game_state.flash_timer > 0:
            game_state.flash_timer -= 1

        renderer.render(game_state)
        clock.tick(FPS)


if __name__ == "__main__":
    main()